name: 'Auto Version Bump with Gemini'
description: 'Analyze git changes using Gemini AI and automatically bump semantic version'
branding:
  icon: 'tag'
  color: 'blue'

inputs:
  gemini-api-key:
    description: 'Gemini API key for change analysis'
    required: true
  diff-range:
    description: 'Git diff range to analyze (e.g., HEAD~1..HEAD or tag..HEAD)'
    required: false
    default: 'HEAD~1..HEAD'
  package-name:
    description: 'Package name for version checking (auto-detected from package.json, setup.py, go.mod, or README)'
    required: false
    default: ''
  project-type:
    description: 'Project type for analysis (auto-detected from file structure, or specify: typescript-library, node-package, react-app, python-package, go-module, generic)'
    required: false
    default: 'auto'
  custom-prompt:
    description: 'Custom analysis prompt (overrides project-type templates)'
    required: false
    default: ''
  main-files:
    description: 'Main source files/patterns that indicate API changes (e.g., "src/index.ts,src/api/*.ts")'
    required: false
    default: ''
  dry-run:
    description: 'Only analyze changes without bumping version'
    required: false
    default: 'false'
  auto-push:
    description: 'Automatically push version bump commit and tag to GitHub'
    required: false
    default: 'true'
  model:
    description: 'Gemini model to use for analysis (e.g., gemini-2.0-flash, gemini-1.5-flash, gemini-1.5-pro)'
    required: false
    default: 'gemini-2.0-flash'

outputs:
  version-bump:
    description: 'Recommended version bump type (major, minor, patch)'
    value: ${{ steps.analyze.outputs.version-bump }}
  current-version:
    description: 'Current version before bump'
    value: ${{ steps.get-version.outputs.current-version }}
  new-version:
    description: 'New version after bump (only if not dry-run)'
    value: ${{ steps.bump.outputs.new-version }}
  needs-bump:
    description: 'Whether version bump is needed'
    value: ${{ steps.check.outputs.needs-bump }}
  version-bumped:
    description: 'Whether version was actually bumped'
    value: ${{ steps.bump.outputs.version-bumped }}
  changelog:
    description: 'Generated changelog for this version'
    value: ${{ steps.analyze.outputs.changelog }}

runs:
  using: 'composite'
  steps:
    - name: Get current version
      id: get-version
      shell: bash
      run: |
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"

    - name: Get git changes
      id: git-changes
      shell: bash
      run: |
        DIFF_RANGE="${{ inputs.diff-range }}"
        echo "Analyzing changes in range: $DIFF_RANGE"
        
        # Get changed files
        CHANGED_FILES=$(git diff --name-only $DIFF_RANGE || echo "")
        echo "changed-files<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Get commit messages
        COMMIT_MESSAGES=$(git log --oneline $DIFF_RANGE || echo "")
        echo "commit-messages<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMIT_MESSAGES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Get full diff (truncated for API limits)
        FULL_DIFF=$(git diff $DIFF_RANGE | head -c 10000 || echo "")
        echo "full-diff<<EOF" >> $GITHUB_OUTPUT
        echo "$FULL_DIFF" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Analyze changes with Gemini
      id: analyze
      uses: actions/github-script@v7
      env:
        GEMINI_API_KEY: ${{ inputs.gemini-api-key }}
        CHANGED_FILES: ${{ steps.git-changes.outputs.changed-files }}
        COMMIT_MESSAGES: ${{ steps.git-changes.outputs.commit-messages }}
        FULL_DIFF: ${{ steps.git-changes.outputs.full-diff }}
      with:
        script: |
          // Project type templates
          const projectTemplates = {
            'typescript-library': {
              description: 'TypeScript library',
              mainFiles: 'src/index.ts,src/**/*.ts,lib/**/*.ts',
              major: [
                'Removed or renamed public functions/exports from main entry files',
                'Changed function signatures (parameters, return types)',
                'Removed or changed public properties/methods',
                'Breaking changes to exported interfaces or types',
                'Any change that would break existing user code importing this library'
              ],
              minor: [
                'Added new public functions/exports to main entry files',
                'Added new optional parameters to existing functions',
                'Added new public interfaces, types, or classes',
                'Backward-compatible enhancements to the public API'
              ],
              patch: [
                'Internal implementation changes without API changes',
                'Bug fixes that don\'t change public API',
                'Documentation updates',
                'Performance improvements with same behavior',
                'Test updates',
                'Build/tooling changes',
                'Dependency updates'
              ]
            },
            'node-package': {
              description: 'Node.js package',
              mainFiles: 'index.js,lib/**/*.js,src/**/*.js',
              major: [
                'Removed or renamed exported functions/modules',
                'Changed function signatures or return values',
                'Removed CLI commands or changed their behavior',
                'Breaking changes to configuration format'
              ],
              minor: [
                'Added new exported functions or modules',
                'Added new CLI commands or options',
                'Added new configuration options',
                'Backward-compatible API enhancements'
              ],
              patch: [
                'Bug fixes without API changes',
                'Internal refactoring',
                'Documentation updates',
                'Performance improvements',
                'Dependency updates',
                'Test improvements'
              ]
            },
            'react-app': {
              description: 'React application',
              mainFiles: 'src/**/*.tsx,src/**/*.ts,public/**/*',
              major: [
                'Breaking changes to public APIs or exported components',
                'Removed or renamed public component props',
                'Major UI/UX changes that break user workflows'
              ],
              minor: [
                'New features or components',
                'New optional props for components',
                'New pages or routes',
                'Enhanced functionality'
              ],
              patch: [
                'Bug fixes',
                'UI polish and minor improvements',
                'Performance optimizations',
                'Internal refactoring',
                'Test updates',
                'Documentation updates',
                'Dependency updates'
              ]
            },
            'python-package': {
              description: 'Python package',
              mainFiles: '**/*.py,setup.py,pyproject.toml',
              major: [
                'Removed or renamed public functions/classes',
                'Changed function signatures or return types',
                'Removed or changed public attributes',
                'Breaking changes to CLI interface',
                'Minimum Python version requirement changes'
              ],
              minor: [
                'Added new public functions/classes',
                'Added new optional parameters',
                'New CLI commands or options',
                'Backward-compatible API enhancements'
              ],
              patch: [
                'Bug fixes without API changes',
                'Internal implementation changes',
                'Documentation updates',
                'Performance improvements',
                'Test updates',
                'Dependency updates'
              ]
            },
            'go-module': {
              description: 'Go module',
              mainFiles: '**/*.go,go.mod,go.sum',
              major: [
                'Removed or renamed exported functions/types/constants',
                'Changed function signatures or return values',
                'Breaking changes to struct fields',
                'Minimum Go version requirement changes'
              ],
              minor: [
                'Added new exported functions/types/constants',
                'Added new optional parameters via function options',
                'Backward-compatible API enhancements'
              ],
              patch: [
                'Bug fixes without API changes',
                'Internal implementation changes',
                'Documentation updates',
                'Performance improvements',
                'Test updates',
                'Dependency updates'
              ]
            },
            'generic': {
              description: 'generic project',
              mainFiles: '',
              major: [
                'Breaking changes that would require users to modify their code',
                'Removed or renamed public APIs, functions, or interfaces',
                'Changed behavior of existing functionality in incompatible ways',
                'Breaking changes to configuration formats or CLI interfaces'
              ],
              minor: [
                'Added new features or functionality',
                'Added new optional configuration options',
                'Backward-compatible API enhancements',
                'New capabilities that don\'t break existing usage'
              ],
              patch: [
                'Bug fixes',
                'Documentation updates',
                'Performance improvements',
                'Internal refactoring without behavioral changes',
                'Test updates',
                'Dependency updates',
                'Build/tooling improvements'
              ]
            }
          };

          // Auto-detect project configuration
          const fs = require('fs');
          const path = require('path');
          
          function detectProjectType() {
            const inputType = '${{ inputs.project-type }}';
            if (inputType && inputType !== 'auto') return inputType;
            
            // Check for specific files/patterns to detect project type
            const files = fs.readdirSync('.');
            
            // TypeScript library patterns
            if (files.includes('tsconfig.json') && 
                (files.includes('src') && fs.existsSync('src/index.ts')) ||
                (fs.existsSync('package.json') && JSON.parse(fs.readFileSync('package.json', 'utf8')).types)) {
              return 'typescript-library';
            }
            
            // React app patterns  
            if (files.includes('package.json')) {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              if (pkg.dependencies?.react || pkg.devDependencies?.react ||
                  pkg.scripts?.start && (pkg.scripts.start.includes('react-scripts') || pkg.scripts.start.includes('vite'))) {
                return 'react-app';
              }
            }
            
            // Python package patterns
            if (files.includes('setup.py') || files.includes('pyproject.toml') || 
                files.includes('requirements.txt') || files.some(f => f.endsWith('.py'))) {
              return 'python-package';
            }
            
            // Go module patterns
            if (files.includes('go.mod') || files.includes('go.sum') || 
                files.some(f => f.endsWith('.go'))) {
              return 'go-module';
            }
            
            // Node.js package patterns
            if (files.includes('package.json') && !files.includes('tsconfig.json')) {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              if (pkg.main || pkg.bin || pkg.exports) {
                return 'node-package';
              }
            }
            
            return 'generic';
          }
          
          function detectPackageName() {
            const inputName = '${{ inputs.package-name }}';
            if (inputName) return inputName;
            
            // Try package.json first
            if (fs.existsSync('package.json')) {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              if (pkg.name) return pkg.name;
            }
            
            // Try setup.py for Python
            if (fs.existsSync('setup.py')) {
              const setupContent = fs.readFileSync('setup.py', 'utf8');
              const nameMatch = setupContent.match(/name\s*=\s*['"](.*?)['"]/);
              if (nameMatch) return nameMatch[1];
            }
            
            // Try pyproject.toml for Python
            if (fs.existsSync('pyproject.toml')) {
              const tomlContent = fs.readFileSync('pyproject.toml', 'utf8');
              const nameMatch = tomlContent.match(/name\s*=\s*['"](.*?)['"]/);
              if (nameMatch) return nameMatch[1];
            }
            
            // Try go.mod for Go
            if (fs.existsSync('go.mod')) {
              const goModContent = fs.readFileSync('go.mod', 'utf8');
              const moduleMatch = goModContent.match(/module\s+(.+)/);
              if (moduleMatch) return moduleMatch[1];
            }
            
            // Try README for project name
            const readmeFiles = ['README.md', 'README.txt', 'readme.md', 'readme.txt'];
            for (const readme of readmeFiles) {
              if (fs.existsSync(readme)) {
                const content = fs.readFileSync(readme, 'utf8');
                const titleMatch = content.match(/^#\s+(.+)/m);
                if (titleMatch) return titleMatch[1].trim();
                break;
              }
            }
            
            // Fallback to repository name
            return process.env.GITHUB_REPOSITORY?.split('/')?.pop() || 'this project';
          }
          
          function detectMainFiles(projectType) {
            const inputFiles = '${{ inputs.main-files }}';
            if (inputFiles) return inputFiles;
            
            const template = projectTemplates[projectType];
            if (template?.mainFiles) return template.mainFiles;
            
            // Additional smart detection based on actual file structure
            const files = [];
            
            if (fs.existsSync('src/index.ts')) files.push('src/index.ts');
            if (fs.existsSync('src/index.js')) files.push('src/index.js');
            if (fs.existsSync('index.ts')) files.push('index.ts');
            if (fs.existsSync('index.js')) files.push('index.js');
            
            // Add common patterns based on what exists
            if (fs.existsSync('src')) files.push('src/**/*');
            if (fs.existsSync('lib')) files.push('lib/**/*');
            if (fs.existsSync('dist')) files.push('dist/**/*');
            
            return files.join(',') || template?.mainFiles || '';
          }
          
          const projectType = detectProjectType();
          const packageName = detectPackageName();
          const mainFiles = detectMainFiles(projectType);
          const customPrompt = '${{ inputs.custom-prompt }}';
          
          console.log(`ðŸ” Auto-detected:`);
          console.log(`  Project Type: ${projectType}`);
          console.log(`  Package Name: ${packageName}`);
          console.log(`  Main Files: ${mainFiles}`);
          
          let analysisPrompt;
          
          // Always get template for changelog generation
          const template = projectTemplates[projectType] || projectTemplates['generic'];
          
          if (customPrompt && customPrompt.trim()) {
            // Use custom prompt if provided
            analysisPrompt = customPrompt + '\n\n## Changed Files:\n' + 
              process.env.CHANGED_FILES + '\n\n## Commit Messages:\n' + 
              process.env.COMMIT_MESSAGES + '\n\n## Full Diff:\n' + 
              process.env.FULL_DIFF + '\n\nRespond with EXACTLY one word: "major", "minor", or "patch"';
          } else {
            // Use template-based prompt
            
            const projectPrefix = packageName ? `The project "${packageName}" ` : 'This project ';
            const mainFilesNote = mainFiles ? `\n\nIMPORTANT: Pay special attention to changes in these main files: ${mainFiles}` : '';
            const majorRules = template.major.map(rule => `- ${rule}`).join('\n');
            const minorRules = template.minor.map(rule => `- ${rule}`).join('\n');
            const patchRules = template.patch.map(rule => `- ${rule}`).join('\n');
            
            analysisPrompt = 'You are analyzing git changes to determine the appropriate semantic version bump for a ' + template.description + '.\n\n' +
              projectPrefix + 'follows semantic versioning (semver.org).\n\n' +
              'SEMANTIC VERSIONING RULES:\n\n' +
              'MAJOR (breaking changes):\n' + majorRules + '\n\n' +
              'MINOR (new features):\n' + minorRules + '\n\n' +
              'PATCH (bug fixes/non-breaking):\n' + patchRules + mainFilesNote + '\n\n' +
              '## Changed Files:\n' + process.env.CHANGED_FILES + '\n\n' +
              '## Commit Messages:\n' + process.env.COMMIT_MESSAGES + '\n\n' +
              '## Full Diff:\n' + process.env.FULL_DIFF + '\n\n' +
              'Respond with EXACTLY one word: "major", "minor", or "patch"';
          }

          const selectedModel = '${{ inputs.model }}';
          console.log(`Using model: ${selectedModel}`);

          try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${process.env.GEMINI_API_KEY}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                contents: [{
                  parts: [{
                    text: analysisPrompt
                  }]
                }],
                generationConfig: {
                  maxOutputTokens: 10,
                  temperature: 0.1
                }
              })
            });

            if (!response.ok) {
              throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            const analysis = result.candidates[0].content.parts[0].text.trim().toLowerCase();
            
            // Validate result
            const validBumps = ['major', 'minor', 'patch'];
            if (!validBumps.includes(analysis)) {
              console.log(`Invalid Gemini response: '${analysis}', defaulting to patch`);
              core.setOutput('version-bump', 'patch');
              return;
            }

            console.log(`ðŸ¤– Gemini analysis result: ${analysis}`);
            core.setOutput('version-bump', analysis);
            
            // Generate changelog with second API call
            const changelogPrompt = 'Generate a concise changelog for this ' + template.description + ' release based on the following changes.\n\n' +
              'Format the output as a bulleted list of changes, grouping by type (Features, Bug Fixes, etc.):\n\n' +
              '## Changed Files:\n' + process.env.CHANGED_FILES + '\n\n' +
              '## Commit Messages:\n' + process.env.COMMIT_MESSAGES + '\n\n' +
              '## Full Diff:\n' + process.env.FULL_DIFF + '\n\n' +
              'Provide a clean, user-friendly changelog focusing on what changed for end users. Exclude internal/build changes unless they affect functionality.';

            try {
              const changelogResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${process.env.GEMINI_API_KEY}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  contents: [{
                    parts: [{
                      text: changelogPrompt
                    }]
                  }],
                  generationConfig: {
                    maxOutputTokens: 500,
                    temperature: 0.3
                  }
                })
              });

              if (changelogResponse.ok) {
                const changelogResult = await changelogResponse.json();
                const changelog = changelogResult.candidates[0].content.parts[0].text.trim();
                core.setOutput('changelog', changelog);
                console.log(`ðŸ“ Generated changelog`);
              } else {
                console.log('Failed to generate changelog, using commit messages');
                const fallbackChangelog = process.env.COMMIT_MESSAGES.split('\n')
                  .filter(msg => msg.trim())
                  .map(msg => `- ${msg.replace(/^[a-f0-9]+\s/, '')}`)
                  .join('\n');
                core.setOutput('changelog', fallbackChangelog);
              }
            } catch (changelogError) {
              console.log('Error generating changelog, using fallback');
              const fallbackChangelog = process.env.COMMIT_MESSAGES.split('\n')
                .filter(msg => msg.trim())
                .map(msg => `- ${msg.replace(/^[a-f0-9]+\s/, '')}`)
                .join('\n');
              core.setOutput('changelog', fallbackChangelog);
            }
            
            // Add to step summary
            await core.summary
              .addHeading('ðŸ“Š Version Analysis')
              .addTable([
                [{data: 'Analysis Result', header: true}, {data: analysis.toUpperCase(), header: false}],
                [{data: 'Changed Files', header: true}, {data: process.env.CHANGED_FILES.split('\n').filter(f => f.trim()).length.toString(), header: false}],
                [{data: 'Commits Analyzed', header: true}, {data: process.env.COMMIT_MESSAGES.split('\n').filter(m => m.trim()).length.toString(), header: false}]
              ])
              .write();

          } catch (error) {
            console.error('Error analyzing changes:', error.message);
            console.log('Defaulting to patch version bump');
            core.setOutput('version-bump', 'patch');
            
            // Generate fallback changelog
            const fallbackChangelog = process.env.COMMIT_MESSAGES.split('\n')
              .filter(msg => msg.trim())
              .map(msg => `- ${msg.replace(/^[a-f0-9]+\s/, '')}`)
              .join('\n');
            core.setOutput('changelog', fallbackChangelog || '- Various improvements and fixes');
          }

    - name: Check if version bump is needed
      id: check
      shell: bash
      run: |
        CURRENT_VERSION="${{ steps.get-version.outputs.current-version }}"
        PACKAGE_NAME="${{ inputs.package-name }}"
        
        # Check if this version is already published
        if npm view "$PACKAGE_NAME@$CURRENT_VERSION" version 2>/dev/null; then
          echo "Version $CURRENT_VERSION already exists, version bump needed"
          echo "needs-bump=true" >> $GITHUB_OUTPUT
        else
          echo "Version $CURRENT_VERSION not published, no bump needed"
          echo "needs-bump=false" >> $GITHUB_OUTPUT
        fi

    - name: Bump version
      id: bump
      if: steps.check.outputs.needs-bump == 'true' && inputs.dry-run == 'false'
      shell: bash
      run: |
        BUMP_TYPE="${{ steps.analyze.outputs.version-bump }}"
        echo "Bumping version: $BUMP_TYPE"
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Bump version using npm
        npm version $BUMP_TYPE --no-git-tag-version
        
        NEW_VERSION=$(node -p "require('./package.json').version")
        echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "version-bumped=true" >> $GITHUB_OUTPUT
        
        echo "âœ… Version bumped from ${{ steps.get-version.outputs.current-version }} to $NEW_VERSION"

    - name: Commit version bump
      if: steps.bump.outputs.version-bumped == 'true'
      shell: bash
      run: |
        NEW_VERSION="${{ steps.bump.outputs.new-version }}"
        BUMP_TYPE="${{ steps.analyze.outputs.version-bump }}"
        
        # Commit the version bump
        git add package.json pnpm-lock.yaml
        git commit -m "chore: bump version to $NEW_VERSION [skip version]

        Automated version bump based on Gemini analysis:
        - Analysis: $BUMP_TYPE version bump
        - Previous commits analyzed: ${{ inputs.diff-range }}
        
        This commit includes [skip version] to prevent recursive workflows."
        
        # Create the tag
        git tag "v$NEW_VERSION"
        
        echo "ðŸ“ Committed version bump and created tag v$NEW_VERSION"

    - name: Push version changes
      id: push
      if: steps.bump.outputs.version-bumped == 'true' && inputs.auto-push == 'true'
      shell: bash
      run: |
        NEW_VERSION="${{ steps.bump.outputs.new-version }}"
        
        # Push the commit and tag
        git push origin HEAD
        git push origin "v$NEW_VERSION"
        
        echo "ðŸš€ Pushed version bump commit and tag v$NEW_VERSION to GitHub"

    - name: Summary
      shell: bash
      run: |
        echo "## ðŸ·ï¸ Auto Version Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Current Version | ${{ steps.get-version.outputs.current-version }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Recommended Bump | ${{ steps.analyze.outputs.version-bump }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Needs Bump | ${{ steps.check.outputs.needs-bump }} |" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.bump.outputs.version-bumped }}" = "true" ]; then
          echo "| New Version | ${{ steps.bump.outputs.new-version }} |" >> $GITHUB_STEP_SUMMARY
          if [ "${{ inputs.auto-push }}" = "true" ]; then
            echo "| Status | âœ… Version bumped, committed, and pushed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Status | âœ… Version bumped and committed (push disabled) |" >> $GITHUB_STEP_SUMMARY
          fi
        elif [ "${{ inputs.dry-run }}" = "true" ]; then
          echo "| Status | ðŸ” Dry run - no changes made |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| Status | â­ï¸ No bump needed |" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Add changelog to summary if available
        if [ -n "${{ steps.analyze.outputs.changelog }}" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“‹ Generated Changelog" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.analyze.outputs.changelog }}" >> $GITHUB_STEP_SUMMARY
        fi